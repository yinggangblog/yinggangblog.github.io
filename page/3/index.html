<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cardioid.gitee.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="WangYingGangBlogs">
<meta property="og:url" content="http://cardioid.gitee.io/page/3/index.html">
<meta property="og:site_name" content="WangYingGangBlogs">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WangYingGangBlogs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://cardioid.gitee.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>WangYingGangBlogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WangYingGangBlogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/09/22/Java/1.8%E6%96%B0%E7%89%B9%E6%80%A7lambda/lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/22/Java/1.8%E6%96%B0%E7%89%B9%E6%80%A7lambda/lambda%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">lambda 表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-22 23:44:38" itemprop="dateCreated datePublished" datetime="2021-09-22T23:44:38+08:00">2021-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-26 16:57:48" itemprop="dateModified" datetime="2022-01-26T16:57:48+08:00">2022-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">lambda 表达式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="java-lambda-表达式中的双冒号的用法"><a href="#java-lambda-表达式中的双冒号的用法" class="headerlink" title="java lambda 表达式中的双冒号的用法"></a>java lambda 表达式中的双冒号的用法</h2><p><strong>类名::方法名</strong></p>
<p>注意是方法名哦，后面没有括号“()”</p>
<p>为啥不要括号，因为这样的是式子并不代表一定会调用这个方法。</p>
<p>这种式子一般是用作<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Lambda&spm=1001.2101.3001.7020">Lambda</a>表达式，Lambda有所谓<strong>懒加载</strong>嘛，不要括号就是说，看情况调用方法。</p>
<blockquote>
<p>例如</p>
</blockquote>
<ol>
<li>表达式:</li>
</ol>
<ul>
<li>person -&gt; person.getAge();</li>
</ul>
<p>可以替换成</p>
<ul>
<li>Person::getAge</li>
</ul>
<ol start="2">
<li>表达式</li>
</ol>
<ul>
<li>() -&gt; new HashMap&lt;&gt;();</li>
</ul>
<p>可以替换成</p>
<ul>
<li>HashMap::new</li>
</ul>
<p>比如表达式person -&gt; person.getAge(); </p>
<p>传入参数是person，</p>
<p>返回值是person.getAge()，那么方法引用Person::getAge就对应着Function&lt;Person,Integer&gt;类型。</p>
<p>题一：下面这段代码，进行的操作是，把List<String>里面的String全部大写并返还新的ArrayList<String>，在前面的例子中我们是这么写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collected = collected.stream().map(string -&gt; string.toUpperCase()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>现在也可以被替换成下面的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collected = collected.stream().map(String::toUpperCase).collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));<span class="comment">//注意发生的变化 </span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/09/21/Java/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/21/Java/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3/" class="post-title-link" itemprop="url">Spring循环依赖解决</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-21 18:14:53" itemprop="dateCreated datePublished" datetime="2021-09-21T18:14:53+08:00">2021-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-11 00:39:56" itemprop="dateModified" datetime="2022-04-11T00:39:56+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring源码初探-IOC-4-Bean的初始化-循环依赖的解决"><a href="#Spring源码初探-IOC-4-Bean的初始化-循环依赖的解决" class="headerlink" title="Spring源码初探-IOC(4)-Bean的初始化-循环依赖的解决"></a>Spring源码初探-IOC(4)-Bean的初始化-循环依赖的解决</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际工作中，经常由于设计不佳或者各种因素，导致类之间相互依赖。这些类可能单独使用时不会出问题，但是在使用Spring进行管理的时候可能就会抛出BeanCurrentlyInCreationException等异常 。当抛出这种异常时表示Spring解决不了该循环依赖，本文将简要说明Spring对于循环依赖的解决方法。</p>
<h2 id="循环依赖的产生和解决的前提"><a href="#循环依赖的产生和解决的前提" class="headerlink" title="循环依赖的产生和解决的前提"></a>循环依赖的产生和解决的前提</h2><p>循环依赖的产生可能有很多种情况，例如：</p>
<ul>
<li>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象</li>
<li>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象，以及反之</li>
<li>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象，以及反之</li>
</ul>
<p>当然，Spring对于循环依赖的解决不是无条件的，首先前提条件是针对scope单例并且没有显式指明不需要解决循环依赖的对象，而且要求该对象没有被代理过。同时Spring解决循环依赖也不是万能，以上三种情况只能解决两种，第一种在构造方法中相互依赖的情况Spring也无力回天。结论先给在这，下面来看看Spring的解决方法，知道了解决方案就能明白为啥第一种情况无法解决了。</p>
<h2 id="Spring对于循环依赖的解决"><a href="#Spring对于循环依赖的解决" class="headerlink" title="Spring对于循环依赖的解决"></a>Spring对于循环依赖的解决</h2><p>Spring循环依赖的理论依据其实是Java基于引用传递，当我们获取到对象的引用时，对象的field或者或属性是可以延后设置的。<br>Spring单例对象的初始化其实可以分为三步：</p>
<ul>
<li>createBeanInstance， 实例化，实际上就是调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate</li>
<li>populateBean，填充属性，这步对spring xml中指定的property进行populate (填充)</li>
<li>initializeBean，调用spring xml中指定的init方法，或者AfterPropertiesSet方法<br>会发生循环依赖的步骤集中在第一步和第二步。</li>
</ul>
<h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>对于单例对象来说，在Spring的整个容器的生命周期内，有且只存在一个对象，很容易想到这个对象应该存在Cache中，Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至使用了“三级缓存”。</p>
<p>“三级缓存”主要是指</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="language-markdown">/** Cache of</span> singleton objects: bean <span class="language-markdown">name --&gt; bean instance <span class="emphasis">*/</span></span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;(<span class="number">256</span>);</span><br><span class="line"><span class="comment"><span class="language-markdown"><span class="emphasis">/*</span>* Cache of</span> singleton factories: bean <span class="language-markdown">name --&gt; ObjectFactory <span class="emphasis">*/</span></span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment"><span class="language-markdown"><span class="emphasis">/*</span>* Cache of</span> early singleton objects: <span class="language-markdown">bean name --&gt; bean instance <span class="emphasis">*/</span></span></span></span><br><span class="line">private <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>从字面意思来说：</p>
<p>singletonObjects指单例对象的cache，</p>
<p>singletonFactories指单例对象工厂的cache，</p>
<p>earlySingletonObjects指提前曝光的单例对象的cache。</p>
<p>以上三个cache构成了三级缓存，Spring就用这三级缓存巧妙的解决了循环依赖问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>回想上篇文章中关于Bean创建的过程，首先Spring会尝试从缓存中获取，这个缓存就是指singletonObjects，主要调用的方法是：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      synchronized (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">         singletonObject = <span class="keyword">this</span>.earlySingletonObjects.<span class="keyword">get</span>(beanName);</span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.<span class="keyword">get</span>(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>首先解释两个参数：</p>
<ul>
<li>isSingletonCurrentlyInCreation 判断对应的单例对象是否在创建中，当单例对象没有被初始化完全(例如A定义的构造函数依赖了B对象，得先去创建B对象，或者在populatebean过程中依赖了B对象，得先去创建B对象，此时A处于创建中)</li>
<li>allowEarlyReference 是否允许从singletonFactories中通过getObject拿到对象</li>
</ul>
<p>分析getSingleton的整个过程，Spring首先从singletonObjects（一级缓存）中尝试获取，如果获取不到并且对象在创建中，则尝试从earlySingletonObjects(二级缓存)中获取，如果还是获取不到并且允许从singletonFactories通过getObject获取，则通过singletonFactory.getObject()(三级缓存)获取。如果获取到了则</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this<span class="selector-class">.earlySingletonObjects</span><span class="selector-class">.put</span>(beanName, singletonObject);</span><br><span class="line">this<span class="selector-class">.singletonFactories</span><span class="selector-class">.remove</span>(beanName);</span><br></pre></td></tr></table></figure>

<p>则移除对应的singletonFactory,将singletonObject放入到earlySingletonObjects，其实就是将三级缓存提升到二级缓存中！</p>
<p>Spring解决循环依赖的诀窍就在于singletonFactories这个cache，这个cache中存的是类型为ObjectFactory，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;&#125;</span><br></pre></td></tr></table></figure>

<p>在bean创建过程中，有两处比较重要的匿名内部类实现了该接口。一处是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125;      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         destroySingleton(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;   &#125;</span><br></pre></td></tr></table></figure>

<p>在上文已经提到，Spring利用其创建bean（这样做真的很不明确呀…）</p>
<p>另一处就是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span>   <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">      <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">   &#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>此处就是解决循环依赖的关键，这段代码发生在createBeanInstance之后，也就是说单例对象此时已经被创建出来的。这个对象已经被生产出来了，虽然还不完美（还没有进行初始化的第二步和第三步），但是已经能被人认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。</p>
<p>这样做有什么好处呢？让我们来分析一下“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，长大成人，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象也蜕变完美了！一切都是这么神奇！！</p>
<p>知道了这个原理时候，肯定就知道为啥Spring不能解决“A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象”这类问题了！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring通过三级缓存加上“提前曝光”机制，配合Java的对象引用原理，比较完美地解决了某些情况下的循环依赖问题！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/09/11/Java/SpringCloud%20Alibaba/nacos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/11/Java/SpringCloud%20Alibaba/nacos/" class="post-title-link" itemprop="url">Nacos的使用笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-11 19:29:17" itemprop="dateCreated datePublished" datetime="2021-09-11T19:29:17+08:00">2021-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-09 18:09:26" itemprop="dateModified" datetime="2022-02-09T18:09:26+08:00">2022-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Nacos-作为注册中心"><a href="#Nacos-作为注册中心" class="headerlink" title="Nacos [作为注册中心]"></a>Nacos [作为注册中心]</h3><p>Nacos 是阿里巴巴开源的一个更易于构建云原生应用的动态服务发现，配置管理和服务管理平台，他是使用 java 编写的，需要依赖 java 环境</p>
<p>Nacos 文档地址： <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a></p>
<h4 id="1、下载-nacos-server"><a href="#1、下载-nacos-server" class="headerlink" title="1、下载 nacos-server"></a>1、下载 nacos-server</h4><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p>
<h4 id="2、启动-nacos-server"><a href="#2、启动-nacos-server" class="headerlink" title="2、启动 nacos-server"></a>2、启动 nacos-server</h4><ul>
<li>cmd 运行startup.cmd 文件</li>
<li>访问localhost:8848&#x2F;nacos&#x2F;</li>
<li>使用默认的 nacos&#x2F;nacos 登录</li>
<li></li>
</ul>
<h4 id="3、注册进入-nacos-中"><a href="#3、注册进入-nacos-中" class="headerlink" title="3、注册进入 nacos 中"></a>3、注册进入 nacos 中</h4><p>1、首先，修改 pom.xml 文件，引入  Nacos Discovery Starter</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、在应用的 &#x2F;resource&#x2F;bootstrap.yml 中配置 Nacos Server地址</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#    nacos</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">         <span class="comment">#    nacos注册中心</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment">#        如果配置格式为yml需要指定文件类型</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">ae34901c-9215-4409-ae61-c6b8d6c8f9b0</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mall-product</span></span><br></pre></td></tr></table></figure>

<p>3、使用@EnableDiscoveryClient 开启服务注册发现功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、启动应用、观察 nacos 服务列表是否已经注册上服务</p>
<p>注意每一个应用都应该有名字，这样才能往册上去。修改pplicaion.propertes文件</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>= <span class="string">service provider</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8000</span></span><br></pre></td></tr></table></figure>

<p>5、注册更多的服务上去，测试使用 feign 远程</p>
<h4 id="Nacos-使用三步"><a href="#Nacos-使用三步" class="headerlink" title="Nacos 使用三步"></a>Nacos 使用三步</h4><p>1、导包</p>
<p>2、写配置，指定 nacos 地址，指定应用的名字</p>
<p>3、开启服务注册发现功能 @EnableDiscoveryClient</p>
<p>Feign 使用三步</p>
<p>1、导包 openfeign</p>
<p>2、开启 @EnableFeignClients 功能</p>
<p>3、编写接口，进行远程调用</p>
<h3 id="Nacos-作为配置中心"><a href="#Nacos-作为配置中心" class="headerlink" title="Nacos [作为配置中心]"></a>Nacos [作为配置中心]</h3><h4 id="1、pom-xml-引入-Nacos-Config-Starter"><a href="#1、pom-xml-引入-Nacos-Config-Starter" class="headerlink" title="1、pom.xml 引入 Nacos Config Starter"></a>1、pom.xml 引入 Nacos Config Starter</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--配置中心来做配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、在应用的-resource-下-bootstrap-properties"><a href="#2、在应用的-resource-下-bootstrap-properties" class="headerlink" title="2、在应用的 resource 下 bootstrap.properties"></a>2、在应用的 resource 下 bootstrap.properties</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  #    nacos</span></span><br><span class="line">  <span class="attr">cloud</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">nacos</span>:<span class="string"></span></span><br><span class="line">      <span class="attr">discovery</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line">      <span class="attr">config</span>:<span class="string"></span></span><br><span class="line">        <span class="attr">server-addr</span>: <span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment">#        如果配置格式为yml需要指定文件类型</span></span><br><span class="line">        <span class="attr">file-extension</span>: <span class="string">yml</span></span><br><span class="line">        <span class="attr">namespace</span>: <span class="string">ae34901c-9215-4409-ae61-c6b8d6c8f9b0</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">application</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">mall-member</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">profiles</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">active</span>: <span class="string">pro</span></span><br></pre></td></tr></table></figure>

<h4 id="3、在-nacos-中添加配置"><a href="#3、在-nacos-中添加配置" class="headerlink" title="3、在 nacos 中添加配置"></a>3、在 nacos 中添加配置</h4><ul>
<li><p>命名规则</p>
<p>​	用户名.应用名.properties</p>
<p>​	mall-gateway.yml</p>
</li>
</ul>
<p>选择右上角添加配置</p>
<p><img src="/nacos/image-20220122002132321.png" alt="image-20220122002132321"></p>
<h4 id="4、在应用中使用-Value-和-RefreshScope"><a href="#4、在应用中使用-Value-和-RefreshScope" class="headerlink" title="4、在应用中使用@Value 和 @RefreshScope"></a>4、在应用中使用@Value 和 @RefreshScope</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">// 刷新对应controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;coupon/coupon&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CouponService couponService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;coupon.user.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;coupon.user.age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.ok().put(<span class="string">&quot;name&quot;</span>,name).put(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>配置集</strong></p>
<p><strong>一组相关或者不相关的配置项的集合称为配置集</strong>。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。</p>
<p><strong>配置集ID:</strong></p>
<p>Nacos 中的某个配置集的 ID，配置集 ID 是组织划分配置的维度之一，<strong>Data ID</strong> 通常用于组织划分系统的配置集，一个系统或者应用可以包含多个配置集，一个系统应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识，Data ID 通常采用类 Java 包 如 ( com.taobao.tc.refund.log.level ) 的命名规则保证全局唯一性，此命名规则非强制</p>
<p><strong>配置分组：</strong></p>
<p>Nacos 中的一组配置集，是组织配置的维度之一，通过一个有意义的字符串，(如 Buy 或 Trade ) 对配置集进行分组，从而区分 Data ID 相同的配置集，当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用，DEFAULT_GROUP 配置分组的常见场景，不同的应用或组件采用了相同的配置类型，如 database_url 配置和 MQ_topic 配置</p>
<p><strong>命名空间:</strong><br>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 <strong>Group</strong> 或 <strong>DatalD</strong> 的配置。<strong>Namespace</strong>  的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源(如配置、服务)隔离等。</p>
<p>开发 测试 生产 利用命名空间来做环境隔离</p>
<p><img src="/nacos/image-20220122002400840.png" alt="image-20220122002400840"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/08/16/Java/SpringCloud%20Alibaba/SpringCloud%20Alibaba/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/16/Java/SpringCloud%20Alibaba/SpringCloud%20Alibaba/" class="post-title-link" itemprop="url">SpringCloud Alibaba Seata笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-16 18:28:07" itemprop="dateCreated datePublished" datetime="2021-08-16T18:28:07+08:00">2021-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-09 18:12:44" itemprop="dateModified" datetime="2022-02-09T18:12:44+08:00">2022-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringCloud/" itemprop="url" rel="index"><span itemprop="name">SpringCloud</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<p><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/index.html">https://seata.io/zh-cn/index.html</a></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><strong>TC (Transaction Coordinator) - 事务协调者</strong></p>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<p><strong>TM (Transaction Manager) - 事务管理器</strong></p>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<p><strong>RM (Resource Manager) - 资源管理器</strong></p>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/07/20/Java/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/nginx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/20/Java/nginx%E7%9A%84%E4%BD%BF%E7%94%A8/nginx/" class="post-title-link" itemprop="url">Nginx的安装及配置</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-20 23:02:41" itemprop="dateCreated datePublished" datetime="2021-07-20T23:02:41+08:00">2021-07-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-26 16:58:46" itemprop="dateModified" datetime="2022-01-26T16:58:46+08:00">2022-01-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><ul>
<li>下载Nginx<code>1.10</code>的docker镜像：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.10</span><br></pre></td></tr></table></figure>

<ul>
<li>先运行一次容器（为了拷贝配置文件）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx  \</span><br><span class="line">-d nginx:1.10</span><br></pre></td></tr></table></figure>

<ul>
<li>将容器内的配置文件拷贝到指定目录：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container <span class="built_in">cp</span> nginx:/etc/nginx /mydata/nginx/</span><br></pre></td></tr></table></figure>

<ul>
<li>修改文件名称：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> /mydata/nginx/nginx /mydata/nginx/conf</span><br></pre></td></tr></table></figure>

<ul>
<li>终止并删除容器：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx</span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>使用如下命令启动Nginx服务：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx  \</span><br><span class="line">-v /mydata/nginx/conf:/etc/nginx \</span><br><span class="line">-d nginx:1.10</span><br></pre></td></tr></table></figure>

<p>解析到nginx</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;         <span class="comment">#监听的端口</span></span><br><span class="line">        server_name  a.keep999.cn;    <span class="comment">#监听的URL</span></span><br><span class="line">        location / &#123;</span><br><span class="line">           proxy_redirect off;</span><br><span class="line">            proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">            proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_pass http:<span class="comment">//47.108.59.73:8080;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h3 id="1-Nginx-搭建域名环境一（反向代理配置）"><a href="#1-Nginx-搭建域名环境一（反向代理配置）" class="headerlink" title="1 Nginx 搭建域名环境一（反向代理配置）"></a>1 Nginx 搭建域名环境一（反向代理配置）</h3><p>什么是 反向代理?</p>
<p><img src="/nginx/image-20201029051037570.png" alt="image-20201029051037570"></p>
<p>vi nginx.conf 文件后在底部有该条语句：</p>
<ul>
<li>引入nginx下的 conf.d 下面的conf文件</li>
<li>那么我们开始在该目录下增加关于 谷粒商城的 nginx</li>
</ul>
<p><img src="/nginx/image-20201029045921936.png" alt="image-20201029045921936"></p>
<p>拷贝原先默认的 conf</p>
<p><img src="/nginx/image-20201029050207857.png" alt="image-20201029050207857"></p>
<p>修改</p>
<p><img src="/nginx/image-20201029050136324.png" alt="image-20201029050136324"></p>
<h3 id="4-2-Nginx-搭建域名环境二-（负载均衡到网关）"><a href="#4-2-Nginx-搭建域名环境二-（负载均衡到网关）" class="headerlink" title="4.2 Nginx 搭建域名环境二 （负载均衡到网关）"></a>4.2 Nginx 搭建域名环境二 （负载均衡到网关）</h3><p> 配置 UpStream</p>
<p><img src="/nginx/image-20201029050256216.png" alt="image-20201029050256216"></p>
<p>使用nginx实现负载平衡的最简单配置如下,官网地址：<a target="_blank" rel="noopener" href="https://nginx.org/en/docs/http/load_balancing.html">https://nginx.org/en/docs/http/load_balancing.html</a></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream myapp1 &#123;</span><br><span class="line">        server srv1.example.com;</span><br><span class="line">        server srv2.example.com;</span><br><span class="line">        server srv3.example.com;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://myapp1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在 本机上 hosts 文件上那个配置 域名映射</p>
<p><img src="/../../%E7%AC%94%E8%AE%B0%20git/brain-map/docs/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E7%BA%A7%E7%AF%87/image/image-20201029050625740.png" alt="image-20201029050625740"></p>
<p>将请求转接给网关后，需要在网关配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">gulimall_host_route</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://gulimall-product</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Host=**.gulimall.com</span></span><br></pre></td></tr></table></figure>

<p>最后放几张图方便理解哈</p>
<p><img src="/nginx/image-20201029050828421.png" alt="image-20201029050828421"></p>
<p><img src="/nginx/image-20201029050901546.png" alt="image-20201029050901546"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/07/11/Java/mybatis/mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/11/Java/mybatis/mybatis/" class="post-title-link" itemprop="url">MyBatis使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-11 13:14:34" itemprop="dateCreated datePublished" datetime="2021-07-11T13:14:34+08:00">2021-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-11 00:43:52" itemprop="dateModified" datetime="2022-04-11T00:43:52+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index"><span itemprop="name">MyBatis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MyBatis-JDK-的动态代理技术"><a href="#MyBatis-JDK-的动态代理技术" class="headerlink" title="MyBatis JDK 的动态代理技术"></a>MyBatis JDK 的动态代理技术</h2><ul>
<li><p>分析动态代理对象如何生成的？ </p>
<p>通过动态代理开发模式，我们只编写一个接口，不写实现类，我们通过 getMapper() 方法最终获取到 <strong>org.apache.ibatis.binding.MapperProxy</strong> 代理对象，然后执行功能，而这个代理对象正是 MyBatis 使用了 JDK 的动态代理技术，帮助我们生成了代理实现类对象。从而可以进行相关持久化操作。 </p>
</li>
<li><p>分析方法是如何执行的？</p>
<p>动态代理实现类对象在执行方法的时候最终调用了 <strong>mapperMethod.execute()</strong> 方法，这个方法中通过 switch 语句根据操作类型来判断是新增、修改、删除、查询操作，最后一步回到了 MyBatis 最原生的 SqlSession 方式来执行增删改查。</p>
<p><strong>Debug跟读源码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.getMapper(StudentMapper.class);</span><br><span class="line">和</span><br><span class="line">mapper.selectAll();</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/Untitled/image-20200820174139362.png" alt="image-20200820174139362"></p>
<h2 id="mybatis使用"><a href="#mybatis使用" class="headerlink" title="mybatis使用"></a>mybatis使用</h2><h2 id="mapper-与xml对应关系"><a href="#mapper-与xml对应关系" class="headerlink" title="mapper 与xml对应关系"></a>mapper 与xml对应关系</h2><p>mapper                              ——————————&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                mapper.xml  </p>
<p><img src="/Untitled/image-20220405173621291.png" alt="image-20220405173621291"></p>
<h2 id="动态sql"><a href="#动态sql" class="headerlink" title="动态sql"></a>动态sql</h2><h3 id="1-where-标签"><a href="#1-where-标签" class="headerlink" title="1.where 标签"></a>1.where 标签</h3><h3 id="2-if-标签"><a href="#2-if-标签" class="headerlink" title="2. if  标签"></a>2. if  标签</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">where</span><span class="operator">&gt;</span>：条件标签。如果有动态条件，则使用该标签代替 <span class="keyword">where</span> 关键字。</span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>if test<span class="operator">=</span>“条件判断”<span class="operator">&gt;</span></span><br><span class="line">	查询条件拼接</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>if<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="/Untitled/image-20220405174735614.png" alt="image-20220405174735614"></p>
<h3 id="3-foreach标签-in-1-2-3"><a href="#3-foreach标签-in-1-2-3" class="headerlink" title="3.foreach标签 ( in (1,2,3))"></a>3.foreach标签 ( in (1,2,3))</h3><p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student  <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure>





<p><img src="/Untitled/image-20220405180436103.png" alt="image-20220405180436103"></p>
<p>collection：参数容器类型， (list-集合， array-数组)。<br>open：开始的 SQL 语句。<br>close：结束的 SQL 语句。<br>item：参数变量名。<br>separator：分隔符。</p>
<p><img src="/mybatis/image-20220410233050827.png" alt="image-20220410233050827"></p>
<h3 id="4-sql片段的抽取"><a href="#4-sql片段的抽取" class="headerlink" title="4.sql片段的抽取"></a>4.sql片段的抽取</h3><p><strong>定义：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;片段名字&quot;</span>&gt;</span> sql片段 <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>引用：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;片段名字&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/Untitled/image-20220405180924111.png" alt="image-20220405180924111"></p>
<h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>字段和实体对象属性的映射关系</p>
<h2 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h2><p>卡号 -人</p>
<p><img src="/mybatis/image-20220405183520673.png" alt="image-20220405183520673"></p>
<h2 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h2><p>班级学生</p>
<p><img src="/mybatis/image-20220411001204161.png" alt="image-20220411001204161"></p>
<h2 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h2><p>学生 课程</p>
<p>多对多</p>
<p><img src="/mybatis/image-20220411002638101.png" alt="image-20220411002638101"></p>
<p>column 属性：<strong>表</strong>中字段名称</p>
<p>property 属性：被包含<strong>对象</strong>的<strong>变量</strong>名</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/06/04/Java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/Java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/" class="post-title-link" itemprop="url">RabbitMQ消息队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-04 14:54:33" itemprop="dateCreated datePublished" datetime="2021-06-04T14:54:33+08:00">2021-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-11 00:51:32" itemprop="dateModified" datetime="2022-04-11T00:51:32+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RabbitMQ安装"><a href="#RabbitMQ安装" class="headerlink" title="RabbitMQ安装"></a>RabbitMQ安装</h2><ul>
<li>下载rabbitmq<code>3.7.15</code>的docker镜像：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.15</span><br></pre></td></tr></table></figure>

<ul>
<li>使用如下命令启动RabbitMQ服务：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 5672:5672 -p 15672:15672 --name rabbitmq \</span><br><span class="line">-d rabbitmq:3.7.15</span><br></pre></td></tr></table></figure>

<ul>
<li>进入容器并开启管理功能：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it rabbitmq /bin/bash</span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>

<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/mall_linux_deploy_02.png" alt="img"></p>
<ul>
<li>开启防火墙：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<ul>
<li>访问地址查看是否安装成功：<a target="_blank" rel="noopener" href="http://192.168.3.101:15672/">http://192.168.3.101:15672</a></li>
</ul>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/mall_linux_deploy_03.png" alt="img"></p>
<ul>
<li>输入账号密码并登录：guest guest</li>
<li>创建帐号并设置其角色为管理员：mall mall  administrator</li>
</ul>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/mall_linux_deploy_04.png" alt="img"></p>
<ul>
<li>创建一个新的虚拟host为：&#x2F;mall</li>
</ul>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/mall_linux_deploy_05.png" alt="img"></p>
<ul>
<li>点击mall用户进入用户配置页面</li>
</ul>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/mall_linux_deploy_06.png" alt="img"></p>
<ul>
<li>给mall用户配置该虚拟host的权限</li>
</ul>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/mall_linux_deploy_07.png" alt="img"></p>
<h2 id="业务场景说明"><a href="#业务场景说明" class="headerlink" title="业务场景说明"></a>业务场景说明</h2><blockquote>
<p>用于解决用户下单以后，订单超时如何取消订单的问题。</p>
</blockquote>
<ul>
<li>用户进行下单操作（会有锁定商品库存、使用优惠券、积分一系列的操作）；</li>
<li>生成订单，获取订单的id；</li>
<li>获取到设置的订单超时时间（假设设置的为60分钟不支付取消订单）；</li>
<li>按订单超时时间发送一个延迟消息给RabbitMQ，让它在订单超时后触发取消订单的操作；</li>
<li>如果用户没有支付，进行取消订单操作（释放锁定商品库存、返还优惠券、返回积分一系列操作）。</li>
</ul>
<h2 id="mall整合RabbitMQ实现延迟消息"><a href="#mall整合RabbitMQ实现延迟消息" class="headerlink" title="mall整合RabbitMQ实现延迟消息"></a>mall整合RabbitMQ实现延迟消息</h2><h3 id="在pom-xml中添加相关依赖"><a href="#在pom-xml中添加相关依赖" class="headerlink" title="在pom.xml中添加相关依赖"></a>在pom.xml中添加相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息队列相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改SpringBoot配置文件"><a href="#修改SpringBoot配置文件" class="headerlink" title="修改SpringBoot配置文件"></a>修改SpringBoot配置文件</h3><blockquote>
<p>修改application.yml文件，在spring节点下添加RabbitMQ相关配置。</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># rabbitmq的连接地址</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># rabbitmq的连接端口号</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/mall</span> <span class="comment"># rabbitmq的虚拟host</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的用户名</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">mall</span> <span class="comment"># rabbitmq的密码</span></span><br><span class="line">  <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#如果对异步消息需要回调必须设置为trueCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<h3 id="添加消息队列的枚举配置类QueueEnum"><a href="#添加消息队列的枚举配置类QueueEnum" class="headerlink" title="添加消息队列的枚举配置类QueueEnum"></a>添加消息队列的枚举配置类QueueEnum</h3><blockquote>
<p>用于延迟消息队列及处理取消订单消息队列的常量定义，包括交换机名称、队列名称、路由键名称。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息队列枚举配置</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">QueueEnum</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_ORDER_CANCEL(<span class="string">&quot;mall.order.direct&quot;</span>, <span class="string">&quot;mall.order.cancel&quot;</span>, <span class="string">&quot;mall.order.cancel&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息通知ttl队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QUEUE_TTL_ORDER_CANCEL(<span class="string">&quot;mall.order.direct.ttl&quot;</span>, <span class="string">&quot;mall.order.cancel.ttl&quot;</span>, <span class="string">&quot;mall.order.cancel.ttl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String exchange;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String routeKey;</span><br><span class="line"></span><br><span class="line">    QueueEnum(String exchange, String name, String routeKey) &#123;</span><br><span class="line">        <span class="built_in">this</span>.exchange = exchange;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.routeKey = routeKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加RabbitMQ的配置"><a href="#添加RabbitMQ的配置" class="headerlink" title="添加RabbitMQ的配置"></a>添加RabbitMQ的配置</h3><blockquote>
<p>用于配置交换机、队列及队列与交换机的绑定关系。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.dto.QueueEnum;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息队列配置</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单消息实际消费队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DirectExchange <span class="title function_">orderDirect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列队列所绑定的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DirectExchange <span class="title function_">orderTtlDirect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder</span><br><span class="line">                .directExchange(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange())</span><br><span class="line">                .durable(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单实际消费队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">orderQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(QueueEnum.QUEUE_ORDER_CANCEL.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单延迟队列（死信队列）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">orderTtlQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getName())</span><br><span class="line">                .withArgument(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, QueueEnum.QUEUE_ORDER_CANCEL.getExchange())<span class="comment">//到期后转发的交换机</span></span><br><span class="line">                .withArgument(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey())<span class="comment">//到期后转发的路由键</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">orderBinding</span><span class="params">(DirectExchange orderDirect,Queue orderQueue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderQueue)</span><br><span class="line">                .to(orderDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单延迟队列绑定到交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">orderTtlBinding</span><span class="params">(DirectExchange orderTtlDirect,Queue orderTtlQueue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(orderTtlQueue)</span><br><span class="line">                .to(orderTtlDirect)</span><br><span class="line">                .with(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在RabbitMQ管理页面可以看到以下交换机和队列"><a href="#在RabbitMQ管理页面可以看到以下交换机和队列" class="headerlink" title="在RabbitMQ管理页面可以看到以下交换机和队列"></a>在RabbitMQ管理页面可以看到以下交换机和队列</h4><p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/arch_screen_62.png" alt="img"> <img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/arch_screen_63.png" alt="img"></p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/arch_screen_64.png" alt="img"> <img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/arch_screen_65.png" alt="img"></p>
<h4 id="交换机及队列说明"><a href="#交换机及队列说明" class="headerlink" title="交换机及队列说明"></a>交换机及队列说明</h4><ul>
<li>mall.order.direct（取消订单消息队列所绑定的交换机）:绑定的队列为mall.order.cancel，一旦有消息以mall.order.cancel为路由键发过来，会发送到此队列。</li>
<li>mall.order.direct.ttl（订单延迟消息队列所绑定的交换机）:绑定的队列为mall.order.cancel.ttl，一旦有消息以mall.order.cancel.ttl为路由键发送过来，会转发到此队列，并在此队列保存一定时间，等到超时后会自动将消息发送到mall.order.cancel（取消订单消息消费队列）。</li>
</ul>
<h3 id="添加延迟消息的发送者CancelOrderSender"><a href="#添加延迟消息的发送者CancelOrderSender" class="headerlink" title="添加延迟消息的发送者CancelOrderSender"></a>添加延迟消息的发送者CancelOrderSender</h3><blockquote>
<p>用于向订单延迟消息队列（mall.order.cancel.ttl）里发送消息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.dto.QueueEnum;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.AmqpException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessagePostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消订单消息的发出者</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelOrderSender</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span>LoggerFactory.getLogger(CancelOrderSender.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Long orderId,<span class="keyword">final</span> <span class="type">long</span> delayTimes)</span>&#123;</span><br><span class="line">        <span class="comment">//给延迟队列发送消息</span></span><br><span class="line">        amqpTemplate.convertAndSend(QueueEnum.QUEUE_TTL_ORDER_CANCEL.getExchange(), QueueEnum.QUEUE_TTL_ORDER_CANCEL.getRouteKey(), orderId, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">                <span class="comment">//给消息设置延迟毫秒值</span></span><br><span class="line">                message.getMessageProperties().setExpiration(String.valueOf(delayTimes));</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LOGGER.info(<span class="string">&quot;send delay message orderId:&#123;&#125;&quot;</span>,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加取消订单消息的接收者CancelOrderReceiver"><a href="#添加取消订单消息的接收者CancelOrderReceiver" class="headerlink" title="添加取消订单消息的接收者CancelOrderReceiver"></a>添加取消订单消息的接收者CancelOrderReceiver</h3><blockquote>
<p>用于从取消订单的消息队列（mall.order.cancel）里接收消息。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.service.OmsPortalOrderService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消订单消息的处理者</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;mall.order.cancel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CancelOrderReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span>LoggerFactory.getLogger(CancelOrderReceiver.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OmsPortalOrderService portalOrderService;</span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;receive delay message orderId:&#123;&#125;&quot;</span>,orderId);</span><br><span class="line">        portalOrderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加OmsPortalOrderService接口"><a href="#添加OmsPortalOrderService接口" class="headerlink" title="添加OmsPortalOrderService接口"></a>添加OmsPortalOrderService接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.common.api.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.dto.OrderParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前台订单管理Service</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OmsPortalOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据提交信息生成订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    CommonResult <span class="title function_">generateOrder</span><span class="params">(OrderParam orderParam)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消单个超时订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加OmsPortalOrderService的实现类OmsPortalOrderServiceImpl"><a href="#添加OmsPortalOrderService的实现类OmsPortalOrderServiceImpl" class="headerlink" title="添加OmsPortalOrderService的实现类OmsPortalOrderServiceImpl"></a>添加OmsPortalOrderService的实现类OmsPortalOrderServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.common.api.CommonResult;</span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.component.CancelOrderSender;</span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.dto.OrderParam;</span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.service.OmsPortalOrderService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前台订单管理Service</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsPortalOrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OmsPortalOrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(OmsPortalOrderServiceImpl.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CancelOrderSender cancelOrderSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CommonResult <span class="title function_">generateOrder</span><span class="params">(OrderParam orderParam)</span> &#123;</span><br><span class="line">        <span class="comment">//todo 执行一系类下单操作，具体参考mall项目</span></span><br><span class="line">        LOGGER.info(<span class="string">&quot;process generateOrder&quot;</span>);</span><br><span class="line">        <span class="comment">//下单完成后开启一个延迟消息，用于当用户没有付款时取消订单（orderId应该在下单后生成）</span></span><br><span class="line">        sendDelayMessageCancelOrder(<span class="number">11L</span>);</span><br><span class="line">        <span class="keyword">return</span> CommonResult.success(<span class="literal">null</span>, <span class="string">&quot;下单成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">//todo 执行一系类取消订单操作，具体参考mall项目</span></span><br><span class="line">        LOGGER.info(<span class="string">&quot;process cancelOrder orderId:&#123;&#125;&quot;</span>,orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessageCancelOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">//获取订单超时时间，假设为60分钟</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">delayTimes</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//发送延迟消息</span></span><br><span class="line">        cancelOrderSender.sendMessage(orderId, delayTimes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="添加OmsPortalOrderController定义接口"><a href="#添加OmsPortalOrderController定义接口" class="headerlink" title="添加OmsPortalOrderController定义接口]"></a>添加OmsPortalOrderController定义接口]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.macro.mall.tiny.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.dto.OrderParam;</span><br><span class="line"><span class="keyword">import</span> com.macro.mall.tiny.service.OmsPortalOrderService;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单管理Controller</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;OmsPortalOrderController&quot;, description = &quot;订单管理&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsPortalOrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OmsPortalOrderService portalOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;根据购物车信息生成订单&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/generateOrder&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">generateOrder</span><span class="params">(<span class="meta">@RequestBody</span> OrderParam orderParam)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> portalOrderService.generateOrder(orderParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进行接口测试"><a href="#进行接口测试" class="headerlink" title="进行接口测试"></a>进行接口测试</h2><h3 id="调用下单接口"><a href="#调用下单接口" class="headerlink" title="调用下单接口"></a>调用下单接口</h3><p>注意：已经将延迟消息时间设置为30秒</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/arch_screen_49.png" alt="img"></p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/arch_screen_50.png" alt="img"></p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97RabbitMQ/arch_screen_51.png" alt="img"></p>
<h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><h4 id="1、引入-Spring-boot-starter-amqp"><a href="#1、引入-Spring-boot-starter-amqp" class="headerlink" title="1、引入 Spring-boot-starter-amqp"></a>1、引入 Spring-boot-starter-amqp</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、application-yml配置"><a href="#2、application-yml配置" class="headerlink" title="2、application.yml配置"></a>2、application.yml配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.56</span><span class="number">.10</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure>

<h4 id="3、测试RabbitMQ"><a href="#3、测试RabbitMQ" class="headerlink" title="3、测试RabbitMQ"></a>3、测试RabbitMQ</h4><h5 id="1、AmqpAdmin-管理组件"><a href="#1、AmqpAdmin-管理组件" class="headerlink" title="1、AmqpAdmin:管理组件"></a>1、AmqpAdmin:管理组件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Exchange</span></span><br><span class="line"><span class="comment">     * 1、如何利用Exchange,Queue,Binding</span></span><br><span class="line"><span class="comment">     *      1、使用AmqpAdmin进行创建</span></span><br><span class="line"><span class="comment">     * 2、如何收发信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//	public DirectExchange(</span></span><br><span class="line">        <span class="comment">//	String name, 交换机的名字</span></span><br><span class="line">        <span class="comment">//	boolean durable, 是否持久</span></span><br><span class="line">        <span class="comment">//	boolean autoDelete, 是否自动删除</span></span><br><span class="line">        <span class="comment">//	Map&lt;String, Object&gt; arguments)</span></span><br><span class="line">        <span class="comment">//	&#123;</span></span><br><span class="line">        <span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;hello-java.exchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">        amqpAdmin.declareExchange(directExchange);</span><br><span class="line">        log.info(<span class="string">&quot;Exchange[&#123;&#125;]创建成功：&quot;</span>,<span class="string">&quot;hello-java.exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// public Queue(String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) &#123;</span></span><br><span class="line">        <span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello-java-queue&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">        amqpAdmin.declareQueue(queue);</span><br><span class="line">        log.info(<span class="string">&quot;Queue[&#123;&#125;]:&quot;</span>,<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// public Binding(String destination, 目的地</span></span><br><span class="line">        <span class="comment">// DestinationType destinationType, 目的地类型</span></span><br><span class="line">        <span class="comment">// String exchange,交换机</span></span><br><span class="line">        <span class="comment">// String routingKey,//路由键</span></span><br><span class="line">        <span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;hello-java-queue&quot;</span>,</span><br><span class="line">                Binding.DestinationType.QUEUE,</span><br><span class="line">                <span class="string">&quot;hello-java.exchange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;hello.java&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        amqpAdmin.declareBinding(binding);</span><br><span class="line">        log.info(<span class="string">&quot;Binding[&#123;&#125;]创建成功&quot;</span>,<span class="string">&quot;hello-java-binding&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="2、RabbitTemplate：消息发送处理组件"><a href="#2、RabbitTemplate：消息发送处理组件" class="headerlink" title="2、RabbitTemplate：消息发送处理组件"></a>2、RabbitTemplate：消息发送处理组件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageTest</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">               <span class="type">OrderReturnReasonEntity</span> <span class="variable">reasonEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderReturnReasonEntity</span>();</span><br><span class="line">               reasonEntity.setId(<span class="number">1l</span>);</span><br><span class="line">               reasonEntity.setCreateTime(<span class="keyword">new</span> <span class="title class_">java</span>.util.Date());</span><br><span class="line">               reasonEntity.setName(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">               <span class="comment">//</span></span><br><span class="line">               <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">               <span class="comment">// 发送的对象类型的消息，可以是一个json</span></span><br><span class="line">               rabbitTemplate.convertAndSend(<span class="string">&quot;hello-java.exchange&quot;</span>,<span class="string">&quot;hello.java&quot;</span>,reasonEntity);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">OrderEntity</span> <span class="variable">orderEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderEntity</span>();</span><br><span class="line">               orderEntity.setOrderSn(UUID.randomUUID().toString());</span><br><span class="line">               rabbitTemplate.convertAndSend(<span class="string">&quot;hello-java.exchange&quot;</span>,<span class="string">&quot;hello.java&quot;</span>,orderEntity);</span><br><span class="line">           &#125;</span><br><span class="line">           log.info(<span class="string">&quot;消息发送完成&#123;&#125;&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/06/02/Java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/Java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/" class="post-title-link" itemprop="url">为什么选择 Kafka消息队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-02 07:41:24" itemprop="dateCreated datePublished" datetime="2021-06-02T07:41:24+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-11 00:51:04" itemprop="dateModified" datetime="2022-04-11T00:51:04+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么选择-Kafka"><a href="#为什么选择-Kafka" class="headerlink" title="为什么选择 Kafka"></a>为什么选择 Kafka</h1><p>再来看看在 Echo 这个项目中，哪些地方使用了消息队列也就是 Kafka：</p>
<img src="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220226165408619.png" alt="image-20220226165408619" style="zoom:80%;" />

<ul>
<li>评论、点赞、关注事件触发通知</li>
<li>发帖事件触发 Elasticsearch 服务器中相应的数据更新</li>
<li>删帖事件触发 Elasticsearch 服务器中相应的数据更新</li>
</ul>
<p>实际上在早期的时候 Kafka 并不是一个合格的消息队列，不过现在已经足够优秀。</p>
<p>不说我们这个用户量比较小的论坛，从大体量的论坛项目来考虑，我觉得 Kafka 比较适合的原因有如下：</p>
<p>1）Kafka 天生支持分布式，Broker、Producer 和 Consumer 都原生自动支持分布式；</p>
<p>2）Kafka 拥有多分区（Partition）和多副本（Replica）机制，能提供比较好的并发能力（负载均衡）以及较高的可用性和可靠性，理论上支持消息无限堆积；</p>
<p>3）而且，在一众消息队列里，Kafka 的性能是比较高的。</p>
<p>点赞、关注、私信等操作都会触发通知，在流量巨大的社交论坛网站中，这个系统通知的需求是非常庞大的，为保证系统的高性能，使用消息队列 Kafka 是个明智的选择。</p>
<h1 id="什么是Producer、Consumer、Broker、Topic、Partition？"><a href="#什么是Producer、Consumer、Broker、Topic、Partition？" class="headerlink" title="什么是Producer、Consumer、Broker、Topic、Partition？"></a>什么是Producer、Consumer、Broker、Topic、Partition？</h1><p>Kafka 将生产者发布的消息发送到 <strong>Topic（主题）</strong> 中，</p>
<p>需要这些消息的消费者可以订阅这些 <strong>Topic（主题）</strong>，如下图所示：</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/KafkaTopicPartitioning.png" alt="Kafka Topic Partition"></p>
<p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p>
<ol>
<li><strong>Producer（生产者）</strong> : 产生消息的一方。</li>
<li><strong>Consumer（消费者）</strong> : 消费消息的一方。</li>
<li>Broker（代理）<strong>实例</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li>
</ol>
<p>同时，你一定也注意到每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p>
<ul>
<li><p><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</p>
</li>
<li><p><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，</p>
<p>并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</p>
</li>
</ul>
<blockquote>
<p>划重点：**Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。这样是不是更好理解一点？</p>
</blockquote>
<h1 id="队列模型了解吗？Kafka-的消息模型知道吗？"><a href="#队列模型了解吗？Kafka-的消息模型知道吗？" class="headerlink" title="队列模型了解吗？Kafka 的消息模型知道吗？"></a>队列模型了解吗？Kafka 的消息模型知道吗？</h1><blockquote>
<p>题外话：早期的 JMS 和 AMQP 属于消息服务领域权威组织所做的相关的标准，</p>
<p>但是，这些标准的进化跟不上消息队列的演进速度，这些标准实际上已经属于废弃状态。</p>
<p>所以，可能存在的情况是：不同的消息队列都有自己的一套消息模型。</p>
</blockquote>
<h4 id="队列模型：早期的消息模型"><a href="#队列模型：早期的消息模型" class="headerlink" title="队列模型：早期的消息模型"></a>队列模型：早期的消息模型</h4><p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B23-1645866333309.png" alt="队列模型"></p>
<p><strong>使用队列（Queue）作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</strong> 比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>队列模型存在的问题：</strong></p>
<p>假如我们存在这样一种情况：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完整的消息内容。</p>
<p>这种情况，队列模型就不好解决了。很多比较杠精的人就说：我们可以为每个消费者创建一个单独的队列，让生产者发送多份。这是一种非常愚蠢的做法，浪费资源不说，还违背了使用消息队列的目的。</p>
<h4 id="发布-订阅模型-Kafka-消息模型"><a href="#发布-订阅模型-Kafka-消息模型" class="headerlink" title="发布-订阅模型:Kafka 消息模型"></a>发布-订阅模型:Kafka 消息模型</h4><p>发布-订阅模型主要是为了解决队列模型存在的问题。</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B-1645866333310.png" alt="发布订阅模型"></p>
<p>发布订阅模型（Pub-Sub） 使用<strong>主题（Topic）</strong> 作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<p><strong>在发布 - 订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布 - 订阅模型在功能层面上是可以兼容队列模型的。</strong></p>
<p><strong>Kafka 采用的就是发布 - 订阅模型。</strong></p>
<blockquote>
<p><strong>RocketMQ 的消息模型和 Kafka 基本是完全一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</strong></p>
</blockquote>
<h1 id="Kafka-的多副本机制了解吗？带来了什么好处？"><a href="#Kafka-的多副本机制了解吗？带来了什么好处？" class="headerlink" title="Kafka 的多副本机制了解吗？带来了什么好处？"></a>Kafka 的多副本机制了解吗？带来了什么好处？</h1><p>还有一点我觉得比较重要的是 Kafka 为分区（Partition）引入了多副本（Replica）机制。</p>
<p>分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。</p>
<p>我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>
<blockquote>
<p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p>
</blockquote>
<p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢？</strong></p>
<ol>
<li>Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li>
<li>Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li>
</ol>
<h1 id="Zookeeper-在-Kafka-中的作用知道吗？"><a href="#Zookeeper-在-Kafka-中的作用知道吗？" class="headerlink" title="Zookeeper 在 Kafka 中的作用知道吗？"></a>Zookeeper 在 Kafka 中的作用知道吗？</h1><blockquote>
<p><strong>要想搞懂 zookeeper 在 Kafka 中的作用 一定要自己搭建一个 Kafka 环境然后自己进 zookeeper 去看一下有哪些文件夹和 Kafka 有关，每个节点又保存了什么信息。</strong></p>
</blockquote>
<p>下图就是我的本地 Zookeeper ，它成功和我本地的 Kafka 关联上（以下文件夹结构借助 idea 插件 Zookeeper tool 实现）。</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/zookeeper-kafka.jpg" alt="img"></p>
<p>ZooKeeper 主要为 Kafka 提供元数据的管理的功能。</p>
<p>从图中我们可以看出，Zookeeper 主要为 Kafka 做了下面这些事情：</p>
<ol>
<li><strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li>
<li><strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li>
<li><strong>负载均衡</strong> ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li>
<li>……</li>
</ol>
<h3 id="Kafka-如何保证消息的消费顺序？"><a href="#Kafka-如何保证消息的消费顺序？" class="headerlink" title="#Kafka 如何保证消息的消费顺序？"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F">#</a>Kafka 如何保证消息的消费顺序？</h3><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p>
<ol>
<li>更改用户会员等级。</li>
<li>根据会员等级计算订单价格。</li>
</ol>
<p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p>
<p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/KafkaTopicPartionsLayout.png" alt="img"></p>
<p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p>
<blockquote>
<p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p>
</blockquote>
<p>所以，我们就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p>
<p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表&#x2F;对象的 id 来作为 key 。</p>
<p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p>
<ol>
<li>1 个 Topic 只对应一个 Partition。</li>
<li>（推荐）发送消息的时候指定 key&#x2F;Partition。</li>
</ol>
<p>当然不仅仅只有上面两种方法，上面两种方法是我觉得比较好理解的，</p>
<h3 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="#Kafka 如何保证消息不丢失"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1">#</a>Kafka 如何保证消息不丢失</h3><h4 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="#生产者丢失消息的情况"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF%E7%9A%84%E6%83%85%E5%86%B5">#</a>生产者丢失消息的情况</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p>
<p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，我们可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p>
<blockquote>
<p><strong>详细代码见我的这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486269&idx=2&sn=ec00417ad641dd8c3d145d74cafa09ce&chksm=cea244f6f9d5cde0c8eb233fcc4cf82e11acd06446719a7af55230649863a3ddd95f78d111de&token=1633957262&lang=zh_CN#rd">Kafka系列第三篇！10 分钟学会如何在 Spring Boot 程序中使用 Kafka 作为消息队列?(opens new window)</a></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SendResult&lt;String, Object&gt; sendResult = kafkaTemplate.send(topic, o).get();</span><br><span class="line"><span class="keyword">if</span> (sendResult.getRecordMetadata() != <span class="literal">null</span>) &#123;</span><br><span class="line">  logger.info(<span class="string">&quot;生产者成功发送消息到&quot;</span> + sendResult.getProducerRecord().topic() + <span class="string">&quot;-&gt; &quot;</span> + sendRe</span><br><span class="line">              sult.getProducerRecord().value().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5</p>
<p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;SendResult&lt;String, Object&gt;&gt; future = kafkaTemplate.send(topic, o);</span><br><span class="line">future.addCallback(result -&gt; logger.info(<span class="string">&quot;生产者成功发送消息到topic:&#123;&#125; partition:&#123;&#125;的消息&quot;</span>, result.getRecordMetadata().topic(), result.getRecordMetadata().partition()),</span><br><span class="line">        ex -&gt; logger.error(<span class="string">&quot;生产者发送消失败，原因：&#123;&#125;&quot;</span>, ex.getMessage()));</span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3</p>
<p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p>
<p><strong>另外这里推荐为 Producer 的<code>retries</code>（重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p>
<h4 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="#消费者丢失消息的情况"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%A2%E5%A4%B1%E6%B6%88%E6%81%AF%E7%9A%84%E6%83%85%E5%86%B5">#</a>消费者丢失消息的情况</h4><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/kafka-offset.jpg" alt="kafka offset"></p>
<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p>
<p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来消息被重新消费的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p>
<h4 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="#Kafka 弄丢了消息"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#kafka-%E5%BC%84%E4%B8%A2%E4%BA%86%E6%B6%88%E6%81%AF">#</a>Kafka 弄丢了消息</h4><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p>
<p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p>
<p><strong>设置 acks &#x3D; all</strong></p>
<p>解决办法就是我们设置 <strong>acks &#x3D; all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p>
<p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks &#x3D; all</strong> 代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p>
<p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p>
<p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p>
<p><strong>设置 min.insync.replicas &gt; 1</strong></p>
<p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p>
<p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p>
<p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p>
<blockquote>
<p><strong>Kafka 0.11.0.0版本开始 unclean.leader.election.enable 参数的默认值由原来的true 改为false</strong></p>
</blockquote>
<p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable &#x3D; false</strong> 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p>
<h3 id="Kafka-如何保证消息不重复消费"><a href="#Kafka-如何保证消息不重复消费" class="headerlink" title="#Kafka 如何保证消息不重复消费"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/high-performance/message-queue/kafka%E7%9F%A5%E8%AF%86%E7%82%B9&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/#kafka-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9">#</a>Kafka 如何保证消息不重复消费</h3><p><strong>kafka出现消息重复消费的原因：</strong></p>
<ul>
<li>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li>
<li>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</p>
</li>
<li><p>将</p>
<p><code>enable.auto.commit</code></p>
<p>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：</p>
<p>什么时候提交offset合适？</p>
<ul>
<li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li>
<li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li>
</ul>
</li>
</ul>
<h1 id="kafka的安装"><a href="#kafka的安装" class="headerlink" title="kafka的安装"></a>kafka的安装</h1><h2 id="1-下载镜像"><a href="#1-下载镜像" class="headerlink" title="1.下载镜像"></a>1.下载镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull wurstmeister/zookeeper  </span><br><span class="line">docker pull wurstmeister/kafka  </span><br></pre></td></tr></table></figure>

<h2 id="2-启动zookeeper容器"><a href="#2-启动zookeeper容器" class="headerlink" title="2.启动zookeeper容器"></a>2.启动zookeeper容器</h2><blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name zookeeper -p 2181:2181 -v /etc/localtime:/etc/localtime wurstmeister/zookeeper</span><br></pre></td></tr></table></figure>
</blockquote>
<p># 如果想修改 zookeeper 配置文件 </p>
<p>docker exec -it name &#x2F;bin&#x2F;bash </p>
<p>cd &#x2F;opt&#x2F;zookeeper-3.4.13&#x2F;conf&#x2F;zoo.cfg</p>
<h2 id="3-启动kafka容器"><a href="#3-启动kafka容器" class="headerlink" title="3.启动kafka容器"></a>3.启动kafka容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 -e KAFKA_ZOOKEEPER_CONNECT=8.144.162.164:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://8.144.162.164:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 -t wurstmeister/kafka</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e KAFKA_BROKER_ID=0 在kafka集群中，每个kafka都有一个BROKER_ID来区分自己</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e KAFKA_ZOOKEEPER_CONNECT=8.144.162.164:2181/kafka 配置zookeeper管理kafka的路径10.9.44.11:2181/kafka</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://8.144.162.164:9092 把kafka的地址端口注册给zookeeper</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 配置kafka的监听端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v /etc/localtime:/etc/localtime 容器时间同步虚拟机的时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里面主要设置了4个参数</p>
<p>KAFKA_BROKER_ID&#x3D;0<br>KAFKA_ZOOKEEPER_CONNECT&#x3D;8.144.162.164:2181<br>KAFKA_ADVERTISED_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;8.144.162.164:9092<br>KAFKA_LISTENERS&#x3D;PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092<br>中间两个参数的8.144.162.164改为宿主机器的IP地址，如果不这么设置，可能会导致在别的机器上访问不到kafka。</p>
<h2 id="4-测试kafka"><a href="#4-测试kafka" class="headerlink" title="4.测试kafka"></a>4.测试kafka</h2><p>进入kafka容器的命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it kafka /bin/bash</span><br></pre></td></tr></table></figure>

<p>进入kafka所在目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd opt/kafka_2.11-2.0.0/</span><br></pre></td></tr></table></figure>

<p>启动消息发送方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic testkafka</span><br></pre></td></tr></table></figure>

<p>克隆会话<br>进入kafka所在目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd opt/kafka_2.11-2.0.0/</span><br></pre></td></tr></table></figure>

<p>启动消息接收方</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic testkafka --from-beginning</span><br></pre></td></tr></table></figure>

<p>在消息发送方输入123456<br>在消息接收方查看<br>如果看到123456 消息发送完成</p>
<h2 id="5-集群搭建"><a href="#5-集群搭建" class="headerlink" title="5.集群搭建"></a>5.集群搭建</h2><p>使用docker命令可快速在同一台机器搭建多个kafka，只需要改变brokerId和端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -d --name kafka1 -p 9093:9093 -e KAFKA_BROKER_ID=1 -e KAFKA_ZOOKEEPER_CONNECT=8.144.162.164:2181/kafka -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://8.144.162.164:9093 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9093 -t wurstmeister/kafka</span><br></pre></td></tr></table></figure>

<h2 id="创建Replication为2，Partition为2的topic"><a href="#创建Replication为2，Partition为2的topic" class="headerlink" title="创建Replication为2，Partition为2的topic"></a>创建Replication为2，Partition为2的topic</h2><p>在kafka容器中的opt&#x2F;kafka_2.12-1.1.0&#x2F;目录下输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper 8.144.162.164:2181/kafka --replication-factor 2 --partitions 2 --topic partopic</span><br></pre></td></tr></table></figure>

<p>–create   创建主题。</p>
<p>–replication-factor   设置分区副本。</p>
<p>–partitions    设置分区数。</p>
<p>–topic    操作的topic名称。</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220227153457445.png" alt="image-20220227153457445"></p>
<h2 id="6-查看topic的状态"><a href="#6-查看topic的状态" class="headerlink" title="6.查看topic的状态"></a>6.查看topic的状态</h2><p>在kafka容器中的opt&#x2F;kafka_2.12-1.1.0&#x2F;目录下输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper 8.144.162.164:2181/kafka --topic partopic</span><br></pre></td></tr></table></figure>



<p>–describe   查看主题详细描述。</p>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bash-5.1# bin/kafka-topics.sh --describe --zookeeper 8.144.162.164:2181/kafka --topic partopic</span><br><span class="line"></span><br><span class="line">Topic: partopic TopicId: zj1vuWG2Q0CyOB2Fv21Fwg PartitionCount: 2       ReplicationFactor: 2    Configs:</span><br><span class="line">        Topic: partopic Partition: 0    Leader: 0       Replicas: 0,1   Isr: 0,1</span><br><span class="line">        Topic: partopic Partition: 1    Leader: 1       Replicas: 1,0   Isr: 1,0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PartitionCount: 2  两个分区</p>
<p>ReplicationFactor: 2两个副本</p>
<p>Partition  分区名字  从0开始  0,1,2</p>
<p>Leader   2个副本分别存储在 2台机器上 分别是0,1    谁是副本的leader    0 这个节点</p>
<p>Replicas </p>
<p>显示每个分区的Leader机器为broker0，在broker0和1上具有备份，Isr代表存活的备份机器中存活的。<br>当停掉kafka1后，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop kafka1</span><br></pre></td></tr></table></figure>

<p>再查看topic状态，输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Topic: partopic TopicId: zj1vuWG2Q0CyOB2Fv21Fwg PartitionCount: 2       ReplicationFactor: 2    Configs:</span><br><span class="line">        Topic: partopic Partition: 0    Leader: 0       Replicas: 0,1   Isr: 0</span><br><span class="line">        Topic: partopic Partition: 1    Leader: 0       Replicas: 1,0   Isr: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">## 查询集群描述</span></span><br><span class="line">bin/kafka-topics.sh --describe --zookeeper 127.0.0.1:2181</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查询集群描述（新）</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --topic foo --describe</span><br></pre></td></tr></table></figure>









<p>一个主题可以分多个分区  </p>
<p>一个分区的数据 只能有一个消费者</p>
<p>如果一个分区挂了怎么办</p>
<p>为了保证数据的可靠性安全性</p>
<p>可以增加副本</p>
<p>副本又分为leader 和 follower  主节点 从节点</p>
<p>处理数据的时候 只针对leader这个副本进行 生产和消费数据</p>
<img src="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220228210818214.png" alt="image-20220228210818214" style="zoom: 50%;" />





<p>leader挂掉之后 follower  有条件可以称为新的leader</p>
<p>kafka有些数据是存储在zookeeper中的</p>
<p>记录服务器节点运行的状态  哪些节点在工作</p>
<p>为了提高吞吐量 引入的分区的概念</p>
<p>消费者角度来说 引入了消费者组的概念</p>
<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220302014739503.png" alt="image-20220302014739503"></p>
<h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Kafka</span></span><br><span class="line"><span class="attr">spring.kafka.bootstrap-servers</span> = <span class="string">8.144.162.164:9092,8.144.162.164:9093</span></span><br><span class="line"><span class="comment"># 该字段见 Kafka 安装包中的 consumer.proerties，可自行修改, 修改完毕后需要重启 Kafka</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#(必需)consumer组id</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.group-id</span> = <span class="string">test-consumer-group</span></span><br><span class="line"><span class="comment">#自动向zookeeper提交offset信息</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.enable-auto-commit</span> = <span class="string">true</span></span><br><span class="line"><span class="comment">#自动更新时间</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.auto-commit-interval</span> = <span class="string">3000</span></span><br></pre></td></tr></table></figure>



<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kafka 模板用来向 kafka 发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/atguigu&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        kafkaTemplate.send(<span class="string">&quot;partopic&quot;</span>, msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接收消息  opt&#x2F;kafka_</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server 8.144.162.164:9092 --topic partopic --from-beginning</span><br></pre></td></tr></table></figure>



<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventConsumer</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费评论、点赞、关注事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &#123;&quot;partopic&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(ConsumerRecord record)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (record == <span class="literal">null</span> || record.value() == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息的内容为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(record.value());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="业务-点赞-关注消息通知"><a href="#业务-点赞-关注消息通知" class="headerlink" title="业务 点赞 关注消息通知"></a>业务 点赞 关注消息通知</h1><p>系统通知是一个很常见且必要的需求，当发生点赞、关注、评论操作的时候，系统就会给相应的用户发送通知。</p>
<p>对于流量巨大的社交网站，系统通知的需求是非常庞大的，那如果只是和私信或者发帖功能一样单纯地用 Ajax 做个异步，显然是远远不够的。所以为了保证系统的性能，这里非常有必要使用消息队列（消息队列三大作用：解耦、异步、消峰），Echo 中选用的是 Kafka。</p>
<p>整体来看就两个需求，发送系统通知和显示系统通知：</p>
<p>1）发送系统通知：</p>
<ul>
<li>A 给 B 点赞，给 B 发送 点赞 类型的系统通知（<code>TOPIC_LIKE</code>）</li>
<li>A 给 B 关注，给 B 发送 关注 类型的系统通知（<code>TOPIC_FOLLOW</code>）</li>
<li>A 给 B 评论 ，给 B 发送 评论 类型的系统通知（<code>TOPIC_COMMNET</code>）</li>
</ul>
<p>整体逻辑就是，当发生比如点赞操作的时候，就会触发消息队列的点赞事件，然后消费者消费这个事件，具体的消费逻辑就是往系统通知表里面插入一条数据（系统通知也使用私信那张表 <code>message</code>，不过系统通知的 <code>from_id</code> 在代码里写死了为 1，表示是系统发送出来的，所以这也就是为什么说大家在部署的时候一定要注意在 user 表中事先存储一个 id &#x3D; 1 的用户）。</p>
<p>2）显示系统通知：</p>
<ul>
<li>系统通知列表（显示点赞、评论、关注三种类型的通知）</li>
<li>系统通知详情（分页显示某一类型所包含的系统通知）</li>
<li>显示未读消息数量</li>
</ul>
<h2 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Kafka--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>





<h2 id="properties-1"><a href="#properties-1" class="headerlink" title="properties"></a>properties</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Kafka</span></span><br><span class="line"><span class="attr">spring.kafka.bootstrap-servers</span> = <span class="string">8.144.162.164:9092,8.144.162.164:9093</span></span><br><span class="line"><span class="comment"># 该字段见 Kafka 安装包中的 consumer.proerties，可自行修改, 修改完毕后需要重启 Kafka</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.group-id</span> = <span class="string">test-consumer-group</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.enable-auto-commit</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">spring.kafka.consumer.auto-commit-interval</span> = <span class="string">3000</span></span><br></pre></td></tr></table></figure>

<h2 id="封装事件对象"><a href="#封装事件对象" class="headerlink" title="封装事件对象"></a>封装事件对象</h2><p>各位不妨想一想，消费者想要通过消费这个消息实现往数据库表 message 中插入一条记录的目的，那么这个消息或者说事件是不是就应该具备 message 表中的所有字段，或者说从消息中能够推出这些字段，对吧。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGFsibzSibk9CDcBZKb4dhIQ9v71NiahibibWgH6wooYpktEsHtQCKWPLqDzRsOic8UqAzmfCicoegp05NC0g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>另外，Kafka 是发布订阅模型，一对多，消息以 Topic（主题）进行分类，生产者将消息发布到某个Topic 中，消费者可以订阅该 Topic。以点赞事件为例，看下图：</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/640" alt="图片"></p>
<h2 id="封装Topic类型"><a href="#封装Topic类型" class="headerlink" title="封装Topic类型"></a>封装Topic类型</h2><p>Topic 的类型定义在CommunityConstant中</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220301191440249.png" alt="image-20220301191440249"></p>
<h2 id="消息封装成事件模型"><a href="#消息封装成事件模型" class="headerlink" title="消息封装成事件模型"></a>消息封装成事件模型</h2><p>如此我们就可以封装成一个这样的事件模型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装事件（用于系统通知）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Event</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String topic; <span class="comment">// 事件类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> userId; <span class="comment">// 事件由谁触发</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityType; <span class="comment">// 实体类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityId; <span class="comment">// 实体 id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> entityUserId; <span class="comment">// 实体的作者(该通知发送给他）</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 存储未来可能需要用到的数据</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>元素介绍</p>
<p>userId 和 entityType</p>
<p>如果用户A给用户B点了赞 那么userId 就是A的id  </p>
<p>系统是发送给B的  那么entityUserId就是B的Id    (对应的是message to_id)</p>
<p>map 存储未来可能需要用到的数据 </p>
<p>可以存储评论的对应的贴在id  (postId)</p>
<h2 id="事件生产者"><a href="#事件生产者" class="headerlink" title="事件生产者"></a>事件生产者</h2><p>EventProducer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.greate.community.event;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.entity.Event;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.core.KafkaTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件的生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireEvent</span><span class="params">(Event event)</span> &#123;</span><br><span class="line">        <span class="comment">// 将事件发布到指定的主题</span></span><br><span class="line">        kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>service调用发送消息的方法即可</p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220302001757359.png" alt="image-20220302001757359"></p>
<h2 id="事件消费者"><a href="#事件消费者" class="headerlink" title="事件消费者"></a>事件消费者</h2><p>事件消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.entity.DiscussPost;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.entity.Event;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.entity.Message;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.service.DiscussPostService;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.service.ElasticsearchService;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.service.MessageService;</span><br><span class="line"><span class="keyword">import</span> com.greate.community.util.CommunityConstant;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.kafka.annotation.KafkaListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventConsumer</span> <span class="keyword">implements</span> <span class="title class_">CommunityConstant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(EventConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscussPostService discussPostService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchService elasticsearchService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费评论、点赞、关注事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &#123;TOPIC_COMMNET, TOPIC_LIKE, TOPIC_FOLLOW&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(ConsumerRecord record)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (record == <span class="literal">null</span> || record.value() == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;消息的内容为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;消息格式错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送系统通知</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.setFromId(SYSTEM_USER_ID);</span><br><span class="line">        message.setToId(event.getEntityUserId());</span><br><span class="line">        message.setConversationId(event.getTopic());</span><br><span class="line">        message.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">&quot;userId&quot;</span>, event.getUserId());</span><br><span class="line">        content.put(<span class="string">&quot;entityType&quot;</span>, event.getEntityType());</span><br><span class="line">        content.put(<span class="string">&quot;entityId&quot;</span>, event.getEntityId());</span><br><span class="line">        <span class="keyword">if</span> (!event.getData().isEmpty()) &#123; <span class="comment">// 存储 Event 中的 Data</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : event.getData().entrySet()) &#123;</span><br><span class="line">                content.put(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        message.setContent(JSONObject.toJSONString(content));</span><br><span class="line"></span><br><span class="line">        messageService.addMessage(message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>消费者做的就是拿到消息之后 根据消息里面的数据 </p>
<ol>
<li>往数据表里添加一条数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费发帖事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &#123;TOPIC_PUBLISH&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePublishMessage</span><span class="params">(ConsumerRecord record)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="literal">null</span> || record.value() == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;消息的内容为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">    <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;消息格式错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">DiscussPost</span> <span class="variable">post</span> <span class="operator">=</span> discussPostService.findDiscussPostById(event.getEntityId());</span><br><span class="line">    elasticsearchService.saveDiscusspost(post);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费删帖事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@KafkaListener(topics = &#123;TOPIC_DELETE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDeleteMessage</span><span class="params">(ConsumerRecord record)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (record == <span class="literal">null</span> || record.value() == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;消息的内容为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Event</span> <span class="variable">event</span> <span class="operator">=</span> JSONObject.parseObject(record.value().toString(), Event.class);</span><br><span class="line">    <span class="keyword">if</span> (event == <span class="literal">null</span>) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;消息格式错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elasticsearchService.deleteDiscusspost(event.getEntityId());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/06/01/Java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/01/Java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">为什么使用消息队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-01 11:21:22" itemprop="dateCreated datePublished" datetime="2021-06-01T11:21:22+08:00">2021-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-11 00:50:30" itemprop="dateModified" datetime="2022-04-11T00:50:30+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-2-AMQP-和-JMS"><a href="#1-2-AMQP-和-JMS" class="headerlink" title="1.2. AMQP 和 JMS"></a>1.2. AMQP 和 JMS</h2><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p>
<h3 id="1-2-1-AMQP"><a href="#1-2-1-AMQP" class="headerlink" title="1.2.1. AMQP"></a>1.2.1. AMQP</h3><p>AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，</p>
<p>AMQP不从API层进行限定，而是直接定义网络交换的数据格式。</p>
<h3 id="1-2-2-JMS"><a href="#1-2-2-JMS" class="headerlink" title="1.2.2. JMS"></a>1.2.2. JMS</h3><p>JMS即Java消息服务（JavaMessage Service）应用程序接口，</p>
<p>是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<h3 id="1-2-3-AMQP-与-JMS-区别"><a href="#1-2-3-AMQP-与-JMS-区别" class="headerlink" title="1.2.3. AMQP 与 JMS 区别"></a>1.2.3. AMQP 与 JMS 区别</h3><ul>
<li>JMS是<strong>定义</strong>了统一的<strong>接口</strong>，来对消息操作进行统一；AMQP是通过<strong>规定协议</strong>来统一数据交互的格式</li>
<li>JMS限定了必须使用<strong>Java语言</strong>；AMQP只是协议，不规定实现方式，因此是<strong>跨语言的</strong>。</li>
<li>JMS规定了<strong>两种消息模式</strong>；而AMQP的<strong>消息模式更加丰富</strong></li>
</ul>
<h4 id="JMS-两种消息模型"><a href="#JMS-两种消息模型" class="headerlink" title="JMS 两种消息模型"></a>JMS 两种消息模型</h4><p><strong>① 点到点（P2P）模型</strong></p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B23.png" alt="队列模型"></p>
<p>使用**队列（Queue）**作为消息通信载体；满足**生产者与消费者模式**，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<p><strong>② 发布&#x2F;订阅（Pub&#x2F;Sub）模型</strong></p>
<p><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B.png" alt="发布订阅模型"></p>
<p>发布订阅模型（Pub&#x2F;Sub） 使用<strong>主题（Topic）**作为消息通信载体，类似于**广播模式**；发布者发布一条消息，该消息通过主题传递给所有的订阅者，</strong>在一条消息广播之后才订阅的用户则是收不到该条消息的**。</p>
<h1 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h1><p>先来说一下为什么要使用消息队列，六个字总结：解耦、异步、消峰。</p>
<p>1）<strong>「解耦」</strong></p>
<p>传统模式下系统间的耦合性太强。怎么说呢，举个例子：系统 A 通过接口调用发送数据到 B、C、D 三个系统，如果将来 E 系统接入或者 B 系统不需要接入了，那么系统 A 还需要修改代码，非常麻烦。</p>
<img src="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220226165123724.png" alt="image-20220226165123724" style="zoom:67%;" />

<p>如果系统 A 产生了一条比较关键的数据，那么它就要时时刻刻考虑 B、C、D、E 四个系统如果挂了该咋办？这条数据它们是否都收到了？显然，系统 A 跟其它系统严重耦合。</p>
<p>而如果我们将数据（消息）写入消息队列，需要消息的系统直接自己从消息队列中消费。这样下来，系统 A 就不需要去考虑要给谁发送数据，不需要去维护这个代码，也不需要考虑其他系统是否调用成功、失败超时等情况，反正我只负责生产，别的我不管。</p>
<img src="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220226165106304.png" alt="image-20220226165106304" style="zoom:50%;" />

<p>2）<strong>「异步」</strong></p>
<p>先来看传统同步的情况，举个例子：系统 A 接收一个用户请求，需要进行写库操作，还需要同样的在 B、C、D 三个系统中进行写库操作。如果 A 自己本地写库只要 1ms，而 B、C、D 三个系统写库分别要 100ms、200ms、300ms。最终请求总延时是 1 + 100 + 200 + 300 &#x3D; 601ms，用户体验大打折扣。</p>
<img src="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220226165136977.png" alt="image-20220226165136977" style="zoom:50%;" />

<p>如果使用消息队列，那么系统 A 就只需要发送 3 条消息到消息队列中就行了，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 1 + 5 &#x3D; 6ms，对于用户而言，体验好感度直接拉满。</p>
<img src="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220226165247399.png" alt="image-20220226165247399" style="zoom:50%;" />

<p>3）<strong>「消峰」</strong></p>
<p>如果没有使用缓存或者消息队列，那么系统就是直接基于数据库 MySQL 的，如果有那么一个高峰期，产生了大量的请求涌入 MySQL，毫无疑问，系统将会直接崩溃。</p>
<p>那如果我们使用消息队列，假设 MySQL 每秒钟最多处理 1k 条数据，而高峰期瞬间涌入了 5k 条数据，不过，这 5k 条数据涌入了消息队列。这样，我们的系统就可以从消息队列中根据数据库的能力慢慢的来拉取请求，不要超过自己每秒能处理的最大请求数量就行。</p>
<p>也就是说消息队列每秒钟 5k 个请求进来，1k 个请求出去，假设高峰期 1 个小时，那么这段时间就可能有几十万甚至几百万的请求积压在消息队列中。不过这个短暂的高峰期积压是完全可以的，因为高峰期过了之后，每秒钟就没有那么多的请求进入消息队列了，但是数据库依然会按照每秒 1k 个请求的速度处理。所以只要高峰期一过，系统就会快速的将积压的消息给处理掉。</p>
<img src="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97kafka/image-20220226165323165.png" alt="image-20220226165323165" style="zoom: 50%;" />

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://cardioid.gitee.io/2021/05/24/Java/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="WangYingGangBlogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WangYingGangBlogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/24/Java/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/Eureka%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Eureka的自我保护机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-24 21:13:54" itemprop="dateCreated datePublished" datetime="2021-05-24T21:13:54+08:00">2021-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-11 00:49:04" itemprop="dateModified" datetime="2022-04-11T00:49:04+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eureka/" itemprop="url" rel="index"><span itemprop="name">Eureka</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Eureka的自我保护机制"><a href="#Eureka的自我保护机制" class="headerlink" title="Eureka的自我保护机制"></a>Eureka的自我保护机制</h1><h3 id="自我保护背景"><a href="#自我保护背景" class="headerlink" title="自我保护背景"></a>自我保护背景</h3><p>首先对Eureka注册中心需要了解的是Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。</p>
<p>默认情况下，</p>
<h3 id="自我保护机制"><a href="#自我保护机制" class="headerlink" title="自我保护机制"></a>自我保护机制</h3><p>官方对于自我保护机制的定义：</p>
<blockquote>
<p>自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。</p>
</blockquote>
<p>自我保护机制的工作机制是：<strong>如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制</strong>，此时会出现以下几种情况：</p>
<ol>
<li>Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。</li>
<li>Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。</li>
<li>当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。</li>
</ol>
<p>因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。</p>
<h3 id="自我保护开关"><a href="#自我保护开关" class="headerlink" title="自我保护开关"></a>自我保护开关</h3><p>Eureka自我保护机制，通过配置 <code>eureka.server.enable-self-preservation</code> 来<code>true</code>打开&#x2F;<code>false</code>禁用自我保护机制，默认打开状态，建议生产环境打开此配置。</p>
<h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><p>开发环境中如果要实现服务失效能自动移除，只需要修改以下配置。</p>
<h5 id="1、-注册中心关闭自我保护机制，修改检查失效服务的时间。"><a href="#1、-注册中心关闭自我保护机制，修改检查失效服务的时间。" class="headerlink" title="1、 注册中心关闭自我保护机制，修改检查失效服务的时间。"></a>1、 注册中心关闭自我保护机制，修改检查失效服务的时间。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">     enable-self-preservation: <span class="literal">false</span></span><br><span class="line">     eviction-interval-timer-in-ms: 3000</span><br></pre></td></tr></table></figure>

<h5 id="2、-微服务修改减短服务心跳的时间。"><a href="#2、-微服务修改减短服务心跳的时间。" class="headerlink" title="2、 微服务修改减短服务心跳的时间。"></a>2、 微服务修改减短服务心跳的时间。</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认90秒</span></span><br><span class="line">lease-expiration-duration-in-seconds:  10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认30秒</span></span><br><span class="line">lease-renewal-interval-in-seconds:  3</span><br></pre></td></tr></table></figure>

<p>以上配置建议在生产环境使用默认的时间配置。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">WangYingGangBlogs</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WangYingGangBlogs</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
